<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="GENERATOR" content="PPWIZARD version 02.213 on WIN2K, FREE tool for Windows, OS/2, DOS and UNIX by Dennis Bareis (http://www.labyrinth.net.au/~dbareis/ppwizard.htm)">
<title>AssumeFPS / ChangeFPS / ConvertFPS Avisynth Filter</title>
<STYLE type=text/css>
A:link {
COLOR: #404a58;TEXT-DECORATION: none
}
A:visited {
COLOR: #404a58;TEXT-DECORATION: none
}
A:active {
COLOR: #404a58;TEXT-DECORATION: none
}
A:hover {
COLOR: #e8f0ff; TEXT-DECORATION: underline
}
.titresmall {
color : 000000;
font-family: Tahoma, Verdana, Arial, Helvetica, sans-serif;
font-size: 16pt;
letter-spacing: 0.15em;
font-weight: bold;
}
</STYLE>
</head>
<body bgcolor=b6cac0>
<span class="titresmall"><a name="AssumeFPS">AssumeFPS</a></span> 
<p><tt>AssumeFPS(</tt><i>clip, float fps, bool &quot;sync_audio&quot;</i><tt>)<br>
  </tt><tt>AssumeFPS(</tt><i>clip, int numerator[, int denominator], bool &quot;sync_audio&quot;</i><tt>)</tt></p>
<p>Dieses Filter &auml;ndert die Frame-Rate ohne die Frame-Anzahl zu &auml;ndern, 
  das Video wird also schneller bzw. langsamer abgespielt, es wird lediglich der 
  Framerate-Wert ver&auml;ndert.<br>
  Wenn <i>sync_audio</i> = true gesetzt wird, wird auch die Sample-Rate vom Audio 
  entsprechend ver&auml;ndert, damit die Spieldauer vom Audio gleich dem Video 
  ist. Die Tonh&ouml;he &auml;ndert sich dadurch.</p>
<p>Das kann z.B. verwendet werden, um ein 24fps-Video (Kinofilm) auf 25fps (PAL) 
  zu bringen, ohne zus&auml;tzliche Frames einf&uuml;gen zu m&uuml;ssen (die kleine 
  Erh&ouml;hung der Tonlage ist kaum h&ouml;rbar).</p>
<p> </p>
<hr>
<span class="titresmall"><a name="ChangeFPS">ChangeFPS</a></span> 
<p><tt>ChangeFPS(</tt><i>clip, float fps</i><tt>)<br>
  ChangeFPS(</tt><i>clip, int numerator[, int denominator]</i><tt>)</tt></p>
<p>Dieses Filter &auml;ndert die Frame-Rate, indem Frames gel&ouml;scht oder dupliziert 
  werden, dadurch &auml;ndert sich auch die Gesamtanzahl der Frames, die Spielzeit 
  bleibt aber gleich.</p>
<hr>
<span class="titresmall"><a name="ConvertFPS">ConvertFPS</a></span><span class="titresmall"><tt><font color="#e8f0ff"> 
[yuy2]</font></tt></span> 
<p><tt>ConvertFPS(</tt><i>clip, float new_rate, int &quot;zone&quot;, int &quot;vbi&quot;</i><tt>)</tt></p>
<p><i>new_rate</i>: die Ziel-Frame-Rate (Ganz- oder Dezimalzahl). Im Modus &quot;Mischen&quot; 
  muss <i>new_rate</i> mindestens 2/3 der Quell-Frame-Rate sein, das Auslassen 
  von Frames zu verhindern. F&uuml;r st&auml;rkeres Herabsetzen der Fame-Rate 
  muss man den Modus &quot;Schalten&quot; verwenden. </p>
<p><i>zone</i>: wenn angegeben, wird der Filter im Modus &quot;Schalten&quot; 
  betrieben, der Wert ist eine Ganzzahl gr&ouml;sser 0. Der Wert gibt die H&ouml;he 
  der Zone an, in der die Frames ineinander &uuml;bergeblendet werden. Ein Wert 
  von 80 ergibt gute Ergebnisse bei Vollbild (480/576 Linien). Der Wert von <i>zone</i> 
  muss kleiner gleich der Anzahl der Linien des Zielframes sein, die der Dauer 
  eines Quell-Frames entsprechen. Das sind normalerweise 5/6 oder 6/5 von der 
  Ziel-Frameh&ouml;he, also einige hundert Linien. Ein Fehler wird erzeugt, wenn 
  ein zu grosser Wert gew&auml;hlt wird. </p>
<p><i>vbi</i>: Im Modus &quot;Schalten&quot; wird damit eine Korrektur f&uuml;r 
  die vertikale Austastl&uuml;cke angegeben. Der Wert gibt die H&ouml;he beim 
  Zielframe in Zeilen an, typische Werte sind vbi=49 bei PAL und vbi=45 bei NTSC 
  (der Wert ist nicht kritisch).</p>
<p>Dieses Filter konvertiert die Frame-Rate vom <i>clip</i> zu einer neuen Rate 
  <i>new_rate</i>, ohne Frames (v&ouml;llig) auszulassen oder (neue) einzuf&uuml;gen, 
  was &auml;hnlich gute Ergebnisse wie mit Standalone-Konvertierungsger&auml;ten 
  ergibt. Das Ergbenis hat (fast) die gleiche Spielzeit wie das Quell-Clip, die 
  Gesamtanzahl &auml;ndert sich entsprechen dem Verh&auml;ltnis der Quell- und 
  Ziel-Frame-Raten. </p>
<p> Das Filter hat zwei Betriebsarten. Wenn das optional Argument <i>zone</i> 
  nicht angegeben ist, werden benachbarte Frames gemischt, wobei diese Mischung 
  mit dem zeitlichen Abstand der beiden Frames zum Zielframe gewichtet wird (der 
  Modus &quot;Mischen&quot;). Wenn <i>zone</i> angegeben ist, wird immer von einem 
  Frame zum n&auml;chsten umgeschaltet, wenn der neue Zielframe beginnt (der Modus 
  &quot;Schalten&quot;), das heisst irgendwo in der Mitte des Zielframes. Dabei 
  wird angenommen, dass das Bild auf einem TV betrachtet wird (nicht auf einem 
  PC!)und jeder Frame von oben nach unten abgetastet wird. Der Parameter <i>zone</i> 
  gibt die Breite der &Uuml;bergangsregion an, in der die zwei Frames gemischt 
  werden (um scharfekantige &Uuml;berg&auml;nge zu vermeiden).</p>
<p> Der Modus &quot;Mischen&quot; erzeugt Blend Mode erzeugt eine leichte Unsch&auml;rfe 
  bei Bewegungen, was ein typischer Artefakt bei Frame-Rate-Umwandlungen ist (kann 
  auch bei kommerziellen Videos oder TV-Programmen beobachtet werden). Bei Interlaced-Material 
  muss das Filter auf die einzelnen Fields angewendet werden, nicht auf die Interlaced-Frames 
  (siehe Beispiel).</p>
<p> Der Modus &quot;Schalten&quot; ist ein Versuch, diese Unsch&auml;rfe zu vermeiden, 
  allerdings kann ein leichtes Flackern und Bewegungsartefakte entstehen. Besonders 
  Schwenks sind anf&auml;llig daf&uuml;r, da die einzelnen Frames bei Szenen mit 
  Bewegung gebogene oder unterbrochene senkrechte Linien zeigen. Auch Szenenwechsel 
  k&ouml;nnen in der Mitte des Frames sichtbar werden. Trotzdem sieht das Ergebnis 
  weniger unscharf aus.</p>
<p> Kein Modus ist also perfekt. Welcher der bessere ist, h&auml;ngt vom eigenen 
  Geschmack und dem verwendeten Filmaterial ab.</p>
<p> Aufwendigere Frame-Rate-Konvertierungen verwenden Algorithmen zur Bewegungsinterpolation, 
  die schwierig zu erstellen sind aber dann wesentlich bessere Ergebnisse liefern. 
</p>
<p></p>
<p>Filmaterial sollte nicht mehrfach mit diesem Filter umgewandelt werden.</p>
<p> Das Audio wird nicht ver&auml;ndert, es bleibt synchron, die L&auml;nge des 
  Audio kann sich ganz leicht von der Video-L&auml;nge nach der Umwandlung unterscheiden, 
  da das Ergebnis ja eine ganzzahlige Anzahl von Frames haben muss. Dieser Effekt 
  wird st&auml;rker ausgepr&auml;gt bei kurzen Clips, der entstehende L&auml;ngenunterschied 
  kann aber ignoriert werden.</p>
<table width="75%" border="1">
  <tr> 
    <td> 
      <pre>Beispiel NTSC-&gt;PAL Umwandlung:</pre>
      <pre>AVISource("NTSC_clip.avi")             # Clip laden
Bob()                                  # Fields trennen und auf volle H&ouml;he bringen
BicubicResize(768,576)                 # Gr&ouml;sse auf PAL (quadratische Pixel) anpassen (f&uuml;r CCIR muss 720,576 verwendet werden)
ConvertFPS(50)                         # Field Rate auf PAL wandeln, Modus &quot;Mischen&quot;
SeparateFields.SelectEvery(4,0,3)      # Bob r&uuml;ckg&auml;ngig machen, &quot;Even Field First&quot;. SelectEvery(4,1,2) f&uuml;r &quot;Odd Field first&quot;
Weave                                  # zur&uuml;ckwandeln von Fields auf Frames</pre>
      <pre>Dieses Beispiel funtioniert auch bei frame-basiertem NTSC-Material, auch bei telecine-Film.
Bei Film-Material ist das Ergebnis bei einem inverse-telecine Filter und
einer Anpassung der Framerate von 23.976 auf 25fps ist das Ergebnis allerdings besser.</pre>
      </td>
  </tr>
</table>
<p>&nbsp;
<FORM>
  <INPUT TYPE="Button" VALUE="Back"
onClick="history.go(-1)">
</form>
</body>
</html>
